// Generated using `moon info`, DON'T EDIT IT
package "dowdiness/arena"

// Values

// Errors

// Types and methods
pub struct Arena[B, G] {
  bump : B
  gen_store : G
  mut generation : Int
  mut count : Int
  slot_size : Int
  max_slots : Int
}
pub fn[B : BumpAllocator, G : GenStore] Arena::alloc(Self[B, G]) -> Ref?
pub fn[B, G] Arena::get_count(Self[B, G]) -> Int
pub fn[B, G] Arena::get_generation(Self[B, G]) -> Int
pub fn[B, G] Arena::get_max_slots(Self[B, G]) -> Int
pub fn[B, G : GenStore] Arena::is_valid(Self[B, G], Ref) -> Bool
pub fn Arena::new(Int, Int) -> Self[MbBump, MbGenStore]
pub fn[B : BumpAllocator, G : GenStore] Arena::new_with(B, G, Int, Int) -> Self[B, G]
pub fn[B : BumpAllocator, G : GenStore] Arena::read_double(Self[B, G], Ref, Int) -> Double?
pub fn[B : BumpAllocator, G : GenStore] Arena::read_int32(Self[B, G], Ref, Int) -> Int?
pub fn[B : BumpAllocator, G] Arena::reset(Self[B, G]) -> Unit
pub fn[B, G : GenStore] Arena::slot_offset(Self[B, G], Ref) -> Int?
pub fn[B : BumpAllocator, G : GenStore] Arena::write_double(Self[B, G], Ref, Int, Double) -> Bool
pub fn[B : BumpAllocator, G : GenStore] Arena::write_int32(Self[B, G], Ref, Int, Int) -> Bool

pub struct AudioArena[B, G] {
  arena : Arena[B, G]
}
pub fn[B : BumpAllocator, G : GenStore] AudioArena::alloc(Self[B, G], AudioFrame) -> TypedRef[AudioFrame]?
pub fn[B : BumpAllocator, G : GenStore] AudioArena::get(Self[B, G], TypedRef[AudioFrame]) -> AudioFrame?
pub fn[B, G : GenStore] AudioArena::is_valid(Self[B, G], TypedRef[AudioFrame]) -> Bool
pub fn AudioArena::new(Int) -> Self[MbBump, MbGenStore]
pub fn[B : BumpAllocator, G : GenStore] AudioArena::new_with(B, G, Int) -> Self[B, G]
pub fn[B : BumpAllocator, G] AudioArena::reset(Self[B, G]) -> Unit
pub fn[B : BumpAllocator, G : GenStore] AudioArena::set(Self[B, G], TypedRef[AudioFrame], AudioFrame) -> Bool

pub struct AudioBufferPool[B, G] {
  arena : Arena[B, G]
  frames_per_buffer : Int
  channels : Int
}
pub fn[B : BumpAllocator, G : GenStore] AudioBufferPool::alloc(Self[B, G]) -> BufferRef?
pub fn[B, G] AudioBufferPool::get_channels(Self[B, G]) -> Int
pub fn[B, G] AudioBufferPool::get_frames_per_buffer(Self[B, G]) -> Int
pub fn[B, G : GenStore] AudioBufferPool::is_valid(Self[B, G], BufferRef) -> Bool
pub fn AudioBufferPool::new(Int, Int, Int) -> Self[MbBump, MbGenStore]
pub fn[B : BumpAllocator, G : GenStore] AudioBufferPool::new_with(B, G, Int, Int, Int) -> Self[B, G]
pub fn[B : BumpAllocator, G : GenStore] AudioBufferPool::read_sample(Self[B, G], BufferRef, Int, Int) -> Double?
pub fn[B : BumpAllocator, G] AudioBufferPool::reset(Self[B, G]) -> Unit
pub fn[B : BumpAllocator, G : GenStore] AudioBufferPool::write_sample(Self[B, G], BufferRef, Int, Int, Double) -> Bool

pub struct AudioFrame {
  left : Double
  right : Double
}
pub fn AudioFrame::new(Double, Double) -> Self
pub impl Storable for AudioFrame
pub impl Eq for AudioFrame
pub impl Show for AudioFrame

pub struct BufferRef {
  inner : Ref
}
pub impl Eq for BufferRef
pub impl Show for BufferRef

pub struct F64Arena[B, G] {
  arena : Arena[B, G]
}
pub fn[B : BumpAllocator, G : GenStore] F64Arena::alloc(Self[B, G], Double) -> TypedRef[Double]?
pub fn[B : BumpAllocator, G : GenStore] F64Arena::get(Self[B, G], TypedRef[Double]) -> Double?
pub fn[B, G : GenStore] F64Arena::is_valid(Self[B, G], TypedRef[Double]) -> Bool
pub fn F64Arena::new(Int) -> Self[MbBump, MbGenStore]
pub fn[B : BumpAllocator, G : GenStore] F64Arena::new_with(B, G, Int) -> Self[B, G]
pub fn[B : BumpAllocator, G] F64Arena::reset(Self[B, G]) -> Unit
pub fn[B : BumpAllocator, G : GenStore] F64Arena::set(Self[B, G], TypedRef[Double], Double) -> Bool

pub struct I32Arena[B, G] {
  arena : Arena[B, G]
}
pub fn[B : BumpAllocator, G : GenStore] I32Arena::alloc(Self[B, G], Int) -> TypedRef[Int]?
pub fn[B : BumpAllocator, G : GenStore] I32Arena::get(Self[B, G], TypedRef[Int]) -> Int?
pub fn[B, G : GenStore] I32Arena::is_valid(Self[B, G], TypedRef[Int]) -> Bool
pub fn I32Arena::new(Int) -> Self[MbBump, MbGenStore]
pub fn[B : BumpAllocator, G : GenStore] I32Arena::new_with(B, G, Int) -> Self[B, G]
pub fn[B : BumpAllocator, G] I32Arena::reset(Self[B, G]) -> Unit
pub fn[B : BumpAllocator, G : GenStore] I32Arena::set(Self[B, G], TypedRef[Int], Int) -> Bool

pub struct MbBump {
  data : FixedArray[Byte]
  mut offset : Int
}
pub fn MbBump::new(Int) -> Self
pub impl BumpAllocator for MbBump

pub struct MbGenStore {
  data : Array[Int]
}
pub fn MbGenStore::new(Int) -> Self
pub impl GenStore for MbGenStore

pub struct Ref {
  index : Int
  generation : Int
}
pub impl Eq for Ref
pub impl Show for Ref

pub struct TypedRef[T] {
  inner : Ref
}
pub impl[T : Eq] Eq for TypedRef[T]
pub impl[T : Show] Show for TypedRef[T]

// Type aliases

// Traits
pub(open) trait BumpAllocator {
  alloc(Self, Int, Int) -> Int?
  reset(Self) -> Unit
  capacity(Self) -> Int
  used(Self) -> Int
  write_int32(Self, Int, Int) -> Bool
  read_int32(Self, Int) -> Int?
  write_double(Self, Int, Double) -> Bool
  read_double(Self, Int) -> Double?
  write_byte(Self, Int, Byte) -> Bool
  read_byte(Self, Int) -> Byte?
}

pub(open) trait GenStore {
  get(Self, Int) -> Int
  set(Self, Int, Int) -> Unit
  length(Self) -> Int
}

pub(open) trait Storable {
  byte_size() -> Int
  write_bytes(Self, FixedArray[Byte], Int) -> Unit
  read_bytes(FixedArray[Byte], Int) -> Self
}
pub impl Storable for Int
pub impl Storable for Double

